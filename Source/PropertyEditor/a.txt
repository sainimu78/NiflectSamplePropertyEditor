#pragma once
#include "ExampleNata.h"
#include "Niflect/Default/DefaultMacroTag.h"
#include "Niflect/Base/Array.h"

NIF_T(CExampleNata())
class CExample0
{
public:
	CExample0();

public:
	NIF_F()
	float m_value;
	NIF_F()
	Niflect::TArray<float> m_float_array;
};

NIF_T(CExampleNata())
class CExample1 : public CExample0
{
public:
	CExample1();

public:
	NIF_F()
	Niflect::TArray<float> m_float_array_1;
	NIF_F()
	float m_value_1;
};#pragma once
#include "Accessor.h"
#include "Accessor/CompoundAccessor_gen.h"

using namespace RwTree;

NIF_T()
class CCompoundAccessor : public CAccessor
{
public:
	virtual Niflect::CNiflectType* GetType() const override { return Niflect::StaticGetType<CCompoundAccessor>(); }

protected:
	virtual bool SaveInstanceImpl(const InstanceType* base, CRwNode* rw) const override
	{
		for (auto& it : this->GetOwnerType()->GetFields())
		{
			ASSERT(!it.GetName().empty());
			auto rwField = CreateRwNode();
			if (it.TypeSaveInstanceToRwNode(base, rwField.Get()))
				AddExistingRwNode(rw, it.GetName(), rwField);
		}
		return true;
	}
	virtual bool LoadInstanceImpl(InstanceType* base, const CRwNode* rw) const override
	{
		for (auto& it : this->GetOwnerType()->GetFields())
		{
			ASSERT(!it.GetName().empty());
			auto rwChild = FindRwNode(rw, it.GetName());
			it.TypeLoadInstanceFromRwNode(base, rwChild);
		}
		return true;
	}
	virtual bool BuildInstanceNodeImpl(CNiflectInstanceNode* node) const override
	{
		for (auto& it : this->GetOwnerType()->GetFields())
		{
			ASSERT(!it.GetName().empty());
			auto fieldNode = Niflect::CreateInstanceNode();
			if (it.TypeBuildInstanceNode(node, fieldNode.Get()))
				node->AddNode(fieldNode);
		}
		return true;
	}
};#pragma once
#include "Accessor.h"
#include "Accessor/ContainerAccessor_gen.h"

using namespace RwTree;

NIF_T()
class CArrayAccessor : public CAccessor
{
public:
	virtual Niflect::CNiflectType* GetType() const override { return Niflect::StaticGetType<CArrayAccessor>(); }
};

template <typename TArrayType>
class TArrayAccessor : public CArrayAccessor
{
protected:
	virtual bool SaveInstanceImpl(const InstanceType* base, CRwNode* rw) const override
	{
		auto& instance = *static_cast<const TArrayType*>(base);
		ASSERT(!rw->IsArray());
		auto rwArray = rw->ToArray();
		auto elemType = this->GetElementType();
		for (auto idx = 0; idx < instance.size(); ++idx)
		{
			auto rwItem = CreateRwNode();
			auto elemBase = &instance[idx];//如std::vector<bool>无法支持, 因此额外定义特化模板 GetElementBaseToX, 也可改用std::vector<uint8>, 或另定义Accessor
			if (elemType->SaveInstanceToRwNode(elemBase, rwItem.Get()))
				rwArray->AddItem(rwItem);
		}
		return true;
	}
	virtual bool LoadInstanceImpl(InstanceType* base, const CRwNode* rw) const override
	{
		auto& instance = *static_cast<TArrayType*>(base);
		ASSERT(rw->IsArray());
		auto rwArray = rw->GetArray();
		auto elemType = this->GetElementType();
		instance.resize(rwArray->GetItemsCount());
		for (auto idx = 0; idx < instance.size(); ++idx)
		{
			auto rwItem = rwArray->GetItem(idx);
			auto elemBase = &instance[idx];
			elemType->LoadInstanceFromRwNode(elemBase, rwItem);
		}
		return true;
	}
	virtual bool BuildInstanceNodeImpl(CNiflectInstanceNode* node) const override
	{
		auto& instance = *static_cast<TArrayType*>(node->GetBase());
		auto elemType = this->GetElementType();
		uint32 idx = 0;
		for (auto& it : instance)
		{
			auto elemNode = Niflect::CreateInstanceNode();
			auto elemBase = &it;
			if (elemNode->InitAndBuild(elemType, elemBase, std::to_string(idx++).c_str(), node))
				node->AddNode(elemNode);
		}
		return true;
	}
};#pragma once
#include "Accessor.h"
#include "Accessor/ValueTypeAccessor_gen.h"

using namespace RwTree;

template <typename TValue>
class TBuiltinTypeAccessor : public CAccessor
{
protected:
	virtual bool SaveInstanceImpl(const InstanceType* base, CRwNode* rw) const override
	{
		auto& instance = *static_cast<const TValue*>(base);
		auto rwValue = rw->ToValue();
		SetRwValueAs<TValue>(rwValue, instance);
		return true;
	}
	virtual bool LoadInstanceImpl(InstanceType* base, const CRwNode* rw) const override
	{
		auto& instance = *static_cast<TValue*>(base);
		ASSERT(rw->IsValue());
		auto rwValue = rw->GetValue();
		instance = GetRwValueAs<TValue>(rwValue);
		return true;
	}
};

//NIF_T()
//class CBoolAccessor : public TBuiltinTypeAccessor<bool>
//{
//};
NIF_T()
class CFloatAccessor : public TBuiltinTypeAccessor<float>
{
public:
	virtual Niflect::CNiflectType* GetType() const override { return Niflect::StaticGetType<CFloatAccessor>(); }
};#pragma once
#include "Niflect/Base/SharedPtr.h"
#include "Niflect/Base/Array.h"
#include "Niflect/Serialization/RwTree.h"
#include "Niflect/NiflectType.h"

class CPropertyNode;
using CSharedPropertyNode = Niflect::TSharedPtr<CPropertyNode>;

class CPropertyEditContext;

class CPropertyUiNode;
class CEditWidgetCreationContext;
class CChildEditWidgetCreationContext;

using namespace RwTree;

using OnCreateEditWidgetFunc = std::function<void(CEditWidgetCreationContext& ctx)>;
using OnCreateChildEditWidgetFunc = std::function<void(CChildEditWidgetCreationContext& ctx, uint32 idx)>;

class CPropertyNode
{
	friend class CPropertyEditScope;
public:
	CPropertyNode(bool falseGroup_trueItem)
		: m_parent(NULL)
		, m_falseGroup_trueItem(falseGroup_trueItem)
		, m_editCtx(NULL)
		, m_uiNode(NULL)
		, m_elemType(NULL)
	{

	}
	~CPropertyNode()
	{
		printf("");
	}
	void InitForNode(CPropertyEditContext* editCtx, CPropertyNode* parent, const Niflect::CString& name)
	{
		m_editCtx = editCtx;
		m_parent = parent;
		m_name = name;
	}
	void InitForContainer(Niflect::CNiflectType* elemType)
	{
		ASSERT(m_elemType == NULL);
		m_elemType = elemType;
	}
	void InitForUi(CPropertyUiNode* uiNode)
	{
		m_uiNode = uiNode;
	}
	bool IsItem() const
	{
		return m_falseGroup_trueItem;
	}
	const Niflect::CString& GetName() const
	{
		return m_name;
	}
	CPropertyNode* GetParent() const
	{
		return m_parent;
	}
	void InsertNode(const CSharedPropertyNode& node, uint32 idx);
	void AddNode(const CSharedPropertyNode& node);
	void DeleteNode(uint32 idx);
	void DeleteLastNode();
	void Clear();
	uint32 GetNodesCount() const
	{
		return static_cast<uint32>(m_vecNode.size());
	}
	void SetOnCreateEditWidgetFunc(const OnCreateEditWidgetFunc& Func)
	{
		m_OnCreateEditWidgetFunc = Func;
	}
	void SetOnCreateChildEditWidgetFunc(const OnCreateChildEditWidgetFunc& Func)
	{
		m_OnCreateChildEditWidgetFunc = Func;
	}

public:
	bool SaveToDefault()
	{
		return this->LoadFromCurrentImpl(&m_rwDefault);
	}
	bool LoadFromDefault()
	{
		return this->SaveToCurrentImpl(&m_rwDefault);
	}
	bool SaveToCurrent(const CRwNode* rw)
	{
		return this->SaveToCurrentImpl(rw);
	}
	bool LoadFromCurrent(CRwNode* rw) const
	{
		return this->LoadFromCurrentImpl(rw);
	}
	bool IsEqualToDefault(const CRwNode* rw) const
	{
		if (rw->IsValue() == m_rwDefault.IsValue())
		{
			auto a = rw->GetValue();
			auto b = m_rwDefault.GetValue();
			if (a->GetType() == b->GetType())
				return rw->GetData() == m_rwDefault.GetData();
		}
		else if(rw->IsArray() == m_rwDefault.IsArray())
		{
			ASSERT(false);//CRwNode 中已记录 DeepSeek 生成的比较函数备用, 如确需可考虑启用
		}
		else
		{
			ASSERT(false);//CRwNode 中已记录 DeepSeek 生成的比较函数备用, 如确需可考虑启用
		}
		return false;
	}
	bool IsDefaultValid() const
	{
		return m_rwDefault.IsValue() || m_rwDefault.IsArray() || m_rwDefault.GetNodesCount() > 0;
	}
	bool SaveToUi(const CRwNode* rw) const
	{
		return this->SaveToUiImpl(rw);
	}
	bool LoadFromUi(CRwNode* rw) const
	{
		return this->LoadFromUiImpl(rw);
	}
	bool SaveForInstanceNode(CRwNode* rw) const;

protected:
	virtual bool SaveToUiImpl(const CRwNode* rw) const { return false; }
	virtual bool LoadFromUiImpl(CRwNode* rw) const { return false; }

	virtual bool SaveToCurrentImpl(const CRwNode* rw) { return false; }
	virtual bool LoadFromCurrentImpl(CRwNode* rw) const { return false; }

public:
	virtual void InitWithUiNode() {}
	virtual void CreateEditWidget(CEditWidgetCreationContext& ctx) {}
	virtual void CreateChildEditWidget(CChildEditWidgetCreationContext& ctx, uint32 idx) {}

public:
	Niflect::TArray<CSharedPropertyNode> m_vecNode;
	Niflect::CString m_name;
	CPropertyNode* m_parent;
	OnCreateEditWidgetFunc m_OnCreateEditWidgetFunc;
	OnCreateChildEditWidgetFunc m_OnCreateChildEditWidgetFunc;
	CPropertyUiNode* m_uiNode;

protected:
	CPropertyEditContext* m_editCtx;
	Niflect::CNiflectType* m_elemType;

private:
	const bool m_falseGroup_trueItem;
	CRwNode m_rwDefault;
};

class CPropertyGroup : public CPropertyNode
{
	typedef CPropertyNode inherited;
public:
	CPropertyGroup()
		: inherited(false)
	{
	}

public:
	static CPropertyGroup* Cast(inherited* base)
	{
		ASSERT(dynamic_cast<CPropertyGroup*>(base) != NULL);
		return static_cast<CPropertyGroup*>(base);
	}
};

class CPropertyItem : public CPropertyNode
{
	typedef CPropertyNode inherited;
public:
	CPropertyItem()
		: inherited(true)
	{
	}

public:
	static CPropertyItem* Cast(inherited* base)
	{
		ASSERT(dynamic_cast<CPropertyItem*>(base) != NULL);
		return static_cast<CPropertyItem*>(base);
	}
};

class CCompoundProperty : public CPropertyGroup
{
};

class CBoolProperty : public CPropertyItem
{
public:
	CBoolProperty();

public:
	void SetValue(bool value);
	bool GetValue() const;

protected:
	virtual bool SaveToCurrentImpl(const CRwNode* rw) override;
	virtual bool LoadFromCurrentImpl(CRwNode* rw) const override;

private:
	bool m_value;
};

class CFloatProperty : public CPropertyItem
{
public:
	CFloatProperty();

public:
	void SetValue(float value);
	float GetValue() const;

protected:
	virtual bool SaveToCurrentImpl(const CRwNode* rw) override;
	virtual bool LoadFromCurrentImpl(CRwNode* rw) const override;

private:
	float m_value;
};

class CArrayProperty : public CPropertyGroup
{
public:
	void AddElement();
	void DeleteLastElement();
	void InsertElement(uint32 idx);
	void DeleteElement(uint32 idx);
	uint32 GetElementsCount() const;
	void Resize(uint32 cnt);

private:
	void InternalInsertElement(uint32 idx);
	void InternalDeleteElement(uint32 idx);
	void UpdateElementsName();

protected:
	virtual bool SaveToCurrentImpl(const CRwNode* rw) override;
	virtual bool LoadFromCurrentImpl(CRwNode* rw) const override;
};#pragma once
#include "Property/PropertyNode.h"
#include "qlineedit.h"
#include "qpushbutton.h"
#include "Qt/Widget/PropertyUiNode_gen.h"

class QPropertyRow;
class QPropertyTree;

class CPropertyUiNode;
using CSharedPropertyUiNode = Niflect::TSharedPtr<CPropertyUiNode>;

class CEditWidgetCreationContext
{
public:
	CEditWidgetCreationContext(CPropertyNode* inProp, QPropertyRow* inRow, QWidget*& outLabelWidget, QWidget*& outEditWidget)
		: m_inProp(inProp)
		, m_inRow(inRow)
		, m_outLabelWidget(outLabelWidget)
		, m_outEditWidget(outEditWidget)
	{
	}
	CPropertyNode* m_inProp;
	QPropertyRow* m_inRow;
	QWidget*& m_outLabelWidget;
	QWidget*& m_outEditWidget;
};

class CChildEditWidgetCreationContext
{
public:
	CChildEditWidgetCreationContext(CPropertyNode* inProp, QPropertyRow* inRow)
		: m_inProp(inProp)
		, m_inRow(inRow)
	{
	}
	CPropertyNode* m_inProp;
	QPropertyRow* m_inRow;
};

using OnCollapserExpandedFunc = std::function<void()>;

class QCollapser : public QPushButton
{
	typedef QPushButton inherited;
public:
	QCollapser(QWidget* parentWidget);

public:
	bool IsExpanded() const;
	void SetExpanded(bool b);

public:
	void SetOnCollapserExpandedFunc(const OnCollapserExpandedFunc& Func);

private:
	bool m_expanded;
	OnCollapserExpandedFunc m_OnCollapserExpandedFunc;
};

class CPropertyUiNode
{
public:
	CPropertyUiNode()
		: m_dataNode(NULL)
		, m_row(NULL)
		, m_tree(NULL)
		, m_labelWidget(NULL)
		, m_editWidget(NULL)
		, m_collapser(NULL)
	{
	}
	~CPropertyUiNode()
	{
		printf("");
	}
	void InitRowWidget(QPropertyTree* tree, CPropertyNode* dataNode, QPropertyRow* row, const Niflect::CString& caption);
	void AddNode(const CSharedPropertyUiNode& uiNode)
	{
		m_vecNode.push_back(uiNode);
	}
	void ResetForRebuilding()
	{
		m_dataNode = NULL;
		m_tree = NULL;
		m_labelWidget = NULL;
		m_editWidget = NULL;
		
		m_row = NULL;
		m_collapser = NULL;
	}
	bool IsValid() const
	{
		return m_dataNode != NULL;
	}

public:
	Niflect::CString m_caption;
	CPropertyNode* m_dataNode;
	QPropertyTree* m_tree;
	QWidget* m_labelWidget;
	QWidget* m_editWidget;
	QPropertyRow* m_row;
	QCollapser* m_collapser;
	Niflect::TArray<CSharedPropertyUiNode> m_vecNode;
};

NIF_T()
class CCompoundPropertyCollapser : public CCompoundProperty
{
	typedef CCompoundProperty inherited;
};

NIF_T()
class CFloatPropertyLineEdit : public CFloatProperty
{
	typedef CFloatProperty inherited;
protected:
	virtual bool SaveToUiImpl(const CRwNode* rw) const override;
	virtual bool LoadFromUiImpl(CRwNode* rw) const override;

public:
	virtual void InitWithUiNode() override;
	virtual void CreateEditWidget(CEditWidgetCreationContext& ctx) override;

private:
	QLineEdit* GetEditWidget() const;
};

using OnArrayEditAddFunc = std::function<void()>;
using OnArrayEditRemoveFunc = std::function<void()>;

class QAddRemoveButtons : public QWidget
{
	typedef QWidget inherited;
public:
	QAddRemoveButtons(QWidget* parentWidget);

public:
	void SetOnArrayEditAdd(const OnArrayEditAddFunc& Func);
	void SetOnArrayEditRemove(const OnArrayEditRemoveFunc& Func);

public:
	void UpdateButtonsState(uint32 currentItemsCount);

private:
	QPushButton* m_add;
	QPushButton* m_remove;
	OnArrayEditAddFunc m_OnAddFunc;
	OnArrayEditRemoveFunc m_OnRemoveFunc;
};

using OnArrayElementEditInsertFunc = std::function<void()>;
using OnArrayElementEditDeleteFunc = std::function<void()>;

class QInsertDeleteButtons : public QWidget
{
	typedef QWidget inherited;
public:
	QInsertDeleteButtons(QWidget* parentWidget);

public:
	void SetOnArrayElementEditInsertFunc(const OnArrayElementEditInsertFunc& Func);
	void SetOnArrayElementEditDeleteFunc(const OnArrayElementEditDeleteFunc& Func);

private:
	QPushButton* m_insert;
	QPushButton* m_delete;
	OnArrayElementEditInsertFunc m_OnInsertFunc;
	OnArrayElementEditDeleteFunc m_OnDeleteFunc;
};

NIF_T()
class CArrayPropertyAddRemoveDeleteInsert : public CArrayProperty
{
	typedef CArrayProperty inherited;
public:
	virtual void CreateEditWidget(CEditWidgetCreationContext& ctx) override;
	virtual void CreateChildEditWidget(CChildEditWidgetCreationContext& ctx, uint32 idx) override;
};#include "Example0.h"

CExample0::CExample0()
	: m_value(1.23f)
{
	m_float_array.resize(3);
}

CExample1::CExample1()
	: m_value_1(2.34f)
{
	m_float_array_1.resize(2);
}#include "QApplication"
#include "Qt/Widget/ExampleWindow.h"
#include "QDesktopWidget"
#ifdef WIN32
#include <Windows.h>
#endif
#include "qtimer.h"
#include "PropertyEditorSystem.h"


static int EditorMain(int argc, char** argv)
{
#ifdef WIN32
    AllocConsole();
    freopen("CONOUT$", "w", stdout);
#endif

    CPropertyEditorSystem sys;
    sys.Init();

    QApplication app(argc, argv);
    QDesktopWidget desktop;
    QRect screenRect = desktop.screenGeometry();
    int width = static_cast<int>(screenRect.width() * 0.8);
    int height = static_cast<int>(screenRect.height() * 0.8);
#ifdef WIN32
#undef min
#endif
    width = std::min(width, 800);
    height = std::min(height, 600);

    QExampleWindow wnd;
    wnd.resize(width, height);
    wnd.show();
    QTimer::singleShot(1000, [&wnd, &sys]()
        {
            wnd.InitTypesSelection(sys.GetTable());
        });
    return app.exec();
}

#ifdef WIN32
static char* CreateCharsFromWChars(int codePage, const wchar_t* aw)
{
    const int required = WideCharToMultiByte(codePage, 0, aw, -1, NULL, 0, NULL, NULL);
    char* result = new char[required];
    WideCharToMultiByte(codePage, 0, aw, -1, result, required, NULL, NULL);
    return result;
}
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
    int argc;
    wchar_t** argvW = CommandLineToArgvW(GetCommandLineW(), &argc);
    if (argvW == NULL)
        return -1;
    char** argv = new char*[argc + 1];
    for (int idx = 0; idx < argc; ++idx)
        argv[idx] = CreateCharsFromWChars(CP_ACP, argvW[idx]);
    argv[argc] = 0;
    auto ret = EditorMain(argc, argv);
    for (int idx = 0; idx < argc; ++idx)
        delete[] argv[idx];
    delete[] argv;
    return ret;
}
#else
int main(int argc, char** argv)
{
    return EditorMain(argc, argv);
}
#endif#include "PropertyEditorSystem.h"
#include "PropertyEditor_private.h"

CPropertyEditorSystem::CPropertyEditorSystem()
	: m_table(NULL)
{

}
void CPropertyEditorSystem::Init()
{
	auto reg = Niflect::GetModuleRegistry();
	reg->InitRegisteredModules();

	ASSERT(reg->GetModulesCount() == 1);
	auto mod = reg->GetModuleByIndex(0);
	m_table = mod->GetTable();
}#pragma once
#include "Niflect/NiflectAccessor.h"

class CAccessor : public Niflect::CNiflectAccessor
{
public:
	virtual Niflect::CNiflectType* GetType() const = 0;

public:
	static CAccessor* Cast(Niflect::CNiflectAccessor* base)
	{
		ASSERT(dynamic_cast<CAccessor*>(base) != NULL);
		return static_cast<CAccessor*>(base);
	}
};

static Niflect::CNiflectType* GetAccessorType(Niflect::CNiflectType* ownerType)
{
	auto accessor = CAccessor::Cast(ownerType->GetAccessor());
	return accessor->GetType();
}#pragma once
#include "Niflect/NiflectAccessorSetting.h"
#include "Accessor/CompoundAccessor.h"
#include "Accessor/ValueTypeAccessor.h"
#include "Accessor/ContainerAccessor.h"

using namespace NiflectAccessorSetting;

NIFAS_B() TSetting<CCompoundAccessor>;
NIFAS_A() TSetting<CFloatAccessor, float>;
template <typename TInstance, typename T>
NIFAS_A() TSetting<TArrayAccessor<TInstance>, Niflect::TArray<T> >;#pragma once
#include "Niflect/NiflectNata.h"

enum class ETypeCategory
{
	Default,
	Reserved,
};

class CExampleNata : public Niflect::CNata
{
	typedef CExampleNata CThis;
public:
	CExampleNata()
		: m_typeCategory(ETypeCategory::Default)
	{

	}
	CThis& SetCategory(ETypeCategory cat)
	{
		m_typeCategory = cat;
		return *this;
	}
	ETypeCategory m_typeCategory;
};#pragma once
#include "Niflect/NiflectTable.h"

class CPropertyEditorSystem
{
public:
	CPropertyEditorSystem();
	void Init();

public:
	Niflect::CNiflectTable* GetTable() const { return m_table; }

private:
	Niflect::CNiflectTable* m_table;
};#include "Property/PropertyEditContext.h"
#include "Property/PropertyNode.h"
#include "Property/PropertyEditContext.h"

void CPropertyNode::InsertNode(const CSharedPropertyNode& node, uint32 idx)
{
	m_editCtx->MarkChanged(node.Get());
	m_vecNode.insert(m_vecNode.begin() + idx, node);
}
void CPropertyNode::AddNode(const CSharedPropertyNode& node)
{
	this->InsertNode(node, this->GetNodesCount());
}
void CPropertyNode::DeleteNode(uint32 idx)
{
	m_editCtx->MarkDeleted(m_vecNode[idx]);
	m_vecNode.erase(m_vecNode.begin() + idx);
}
void CPropertyNode::DeleteLastNode()
{
	this->DeleteNode(this->GetNodesCount() - 1);
}
void CPropertyNode::Clear()
{
	for (auto& it : m_vecNode)
		m_editCtx->MarkDeleted(it);
	m_vecNode.clear();
}
bool CPropertyNode::SaveForInstanceNode(CRwNode* rw) const
{
	if (this->IsItem())
	{
		this->LoadFromCurrent(rw);
	}
	else
	{
		if (m_elemType != NULL)
		{
			auto rwArray = rw->ToArray();
			for (auto& it : m_vecNode)
			{
				auto rwElem = CreateRwNode();
				if (it->SaveForInstanceNode(rwElem.Get()))
					rwArray->AddItem(rwElem);
			}
		}
		else
		{
			for (auto& it : m_vecNode)
			{
				auto rwField = CreateRwNode();
				if (it->SaveForInstanceNode(rwField.Get()))
					AddExistingRwNode(rw, it->m_name, rwField);
			}
		}
	}
	return true;
}

CBoolProperty::CBoolProperty()
	: m_value(false)
{
}
void CBoolProperty::SetValue(bool value)
{
	m_value = value;
}
bool CBoolProperty::GetValue() const
{
	return m_value;
}
bool CBoolProperty::SaveToCurrentImpl(const CRwNode* rw)
{
	m_value = GetRwValueAs<bool>(rw->GetValue());
	return true;
}
bool CBoolProperty::LoadFromCurrentImpl(CRwNode* rw) const
{
	SetRwValueAs<bool>(rw->ToValue(), m_value);
	return true;
}

CFloatProperty::CFloatProperty()
	: m_value(0.0f)
{
}
void CFloatProperty::SetValue(float value)
{
	m_value = value;
}
float CFloatProperty::GetValue() const
{
	return m_value;
}
bool CFloatProperty::SaveToCurrentImpl(const CRwNode* rw)
{
	m_value = GetRwValueAs<float>(rw->GetValue());
	return true;
}
bool CFloatProperty::LoadFromCurrentImpl(CRwNode* rw) const
{
	SetRwValueAs<float>(rw->ToValue(), m_value);
	return true;
}

void CArrayProperty::AddElement()
{
	this->InternalInsertElement(this->GetElementsCount());
	this->UpdateElementsName();
}
void CArrayProperty::DeleteLastElement()
{
	this->InternalDeleteElement(this->GetElementsCount() - 1);
	this->UpdateElementsName();
}
void CArrayProperty::InsertElement(uint32 idx)
{
	this->InternalInsertElement(idx);
	this->UpdateElementsName();
}
void CArrayProperty::DeleteElement(uint32 idx)
{
	this->InternalDeleteElement(idx);
	this->UpdateElementsName();
}
uint32 CArrayProperty::GetElementsCount() const
{
	return this->GetNodesCount();
}
void CArrayProperty::Resize(uint32 cnt)
{
	int32 diff = this->GetElementsCount() - cnt;
	while (diff > 0)
	{
		this->InternalDeleteElement(this->GetElementsCount() - 1);
		diff--;
	}
	diff = cnt - this->GetElementsCount();
	while (diff > 0)
	{
		this->InternalInsertElement(this->GetElementsCount());
		diff--;
	}
	ASSERT(this->GetElementsCount() == cnt);
	this->UpdateElementsName();
}
void CArrayProperty::InternalInsertElement(uint32 idx)
{
	ASSERT(m_elemType != NULL);
	auto elem = Niflect::NiflectTypeMakeShared<CPropertyNode>(m_elemType);
	elem->InitForNode(m_editCtx, this, "");
	this->InsertNode(elem, idx);
}
void CArrayProperty::InternalDeleteElement(uint32 idx)
{
	this->DeleteNode(idx);
}
void CArrayProperty::UpdateElementsName()
{
	for (uint32 idx = 0; idx < m_vecNode.size(); ++idx)
	{
		auto& it = m_vecNode[idx];
		it->m_name = std::to_string(idx).c_str();
	}
}
bool CArrayProperty::SaveToCurrentImpl(const CRwNode* rw)
{
	auto cnt = GetRwValueAs<uint32>(rw->GetValue());
	this->Resize(cnt);
	return true;
}
bool CArrayProperty::LoadFromCurrentImpl(CRwNode* rw) const
{
	//Element 初始值也作为数组属性默认值的罕见需求是可行的, 但须区分保存载入的是否作默认值, 流程上显得繁琐.
	SetRwValueAs<uint32>(rw->ToValue(), this->GetElementsCount());
	return true;
}#pragma once
#include "Property/PropertyNode.h"

class CPropertyEditContext
{
	friend class QPropertyTree;
public:
	void MarkChanged(CPropertyNode* prop)
	{
		m_vecChanged.push_back(prop);
	}
	void MarkDeleted(const CSharedPropertyNode& prop)
	{
		//m_vecDeleted.push_back(prop);
	}

private:
	Niflect::TArray<CPropertyNode*> m_vecChanged;
	//Niflect::TArray<CSharedPropertyNode> m_vecDeleted;
};

namespace PropertyTreeUtil
{
	static void DebugPrintPropertyRecurs(CPropertyNode* prop, uint32 depth = 0)
	{
		auto strDepth = NiflectUtil::DebugIndentToString(depth);
		auto propName = prop->m_name;
		if (propName.empty())
			propName = "Not a field";
		Niflect::CString propValue;
		if (prop->IsItem())
		{
			auto item = CPropertyItem::Cast(prop);
			CRwNode rw;
			item->LoadFromCurrent(&rw);
			ASSERT(rw.IsValue());
			switch (rw.GetValue()->GetType())
			{
			case ERwValueType::Float:
			{
				Niflect::CStringStream ss;
				ss << rw.GetValue()->GetFloat();
				propValue = ss.str();
				break;
			}
			default:
				ASSERT(false);
				break;
			}
		}
		if (propValue.empty())
			propValue = "Not an item";
		printf("%s%s, %s\n", strDepth.c_str(), propName.c_str(), propValue.c_str());

		depth++;
		for (auto& it : prop->m_vecNode)
			DebugPrintPropertyRecurs(it.Get(), depth);
	}
}#include "Qt/Util/CoreUtil.h"

QString CStringToQString(const Niflect::CString& str)
{
	return QString::fromLocal8Bit(str.c_str());
}
Niflect::CString QStringToCString(const QString& qstr) {
	QByteArray byteArray = qstr.toUtf8();
	return Niflect::CString(byteArray.constData(), byteArray.size());
}#include "Qt/Util/WidgetUtil.h"#pragma once
#include "Niflect/Base/String.h"
#include "qstring.h"

QString CStringToQString(const Niflect::CString& str);
Niflect::CString QStringToCString(const QString& qstr);#pragma once
#include "qwidget.h"
#include "qpushbutton.h"

template <typename T>
T* CreateLayoutNoMargin(QWidget* owner)
{
	auto layout = new T(owner);
	layout->setMargin(0);
	return layout;
}
static QPushButton* CreateSmallButton(const QString& cap, QWidget* parentWidget)
{
	auto btn = new QPushButton(cap, parentWidget);
	btn->setFixedWidth(40);
	return btn;
}
template <typename TQtObject, typename TMethod, typename ...TArgs>
static void InvokeNoSignal(TQtObject* object, TMethod MemberFunc, TArgs&& ...args)
{
	bool wasBlocked = object->signalsBlocked();
	object->blockSignals(true);
	(object->*MemberFunc)(std::forward<TArgs>(args)...);
	object->blockSignals(wasBlocked);
}
static void InitPushButtonInPropertyLabelStyle(QPushButton* wdg)
{
	wdg->setSizePolicy(QSizePolicy::Expanding, wdg->sizePolicy().verticalPolicy());
	wdg->setStyleSheet(
R"(QPushButton {
text-align: left;
})"
	);
}#include "Qt/Widget/ExampleWindow.h"
#include "qboxlayout.h"
#include "Qt/Util/CoreUtil.h"
#include "Qt/Widget/PropertyTree.h"
#include "Niflect/Serialization/JsonFormat.h"
#include "Niflect/Util/FileStreamUtil.h"
#include "Accessor.h"

#include "Accessor/ValueTypeAccessor.h"
#include "Accessor/CompoundAccessor.h"
#include "Accessor/ContainerAccessor.h"

using namespace PropertyTreeUtil;

Niflect::TMap<Niflect::CNiflectType*, Niflect::CNiflectType*> g_mapAcsToPropType;

static void BuildPropertyFromRwNodeRecurs(CPropertyEditContext* editCtx, Niflect::CNiflectType* ownerType, const CRwNode* rw, const Niflect::CString& name, CPropertyNode* propParent, CPropertyNode* prop)
{
	prop->InitForNode(editCtx, propParent, name);
	prop->SaveToCurrent(rw);
	if (rw->IsValue())
	{
	}
	else if (rw->IsArray())
	{
		auto elemType = ownerType->GetAccessor()->GetElementType();
		ASSERT(elemType == NULL || rw->IsArray());
		auto rwArray = rw->GetArray();
		auto& propType = g_mapAcsToPropType.at(GetAccessorType(elemType));
		prop->InitForContainer(propType);
		for (uint32 idx = 0; idx < rwArray->GetItemsCount(); ++idx)
		{
			auto elemProp = Niflect::NiflectTypeMakeShared<CPropertyNode>(propType);
			BuildPropertyFromRwNodeRecurs(editCtx, elemType, rwArray->GetItem(idx), std::to_string(idx).c_str(), prop, elemProp.Get());
			prop->AddNode(elemProp);
		}
	}
	else
	{
		Niflect::TArray<Niflect::CField> vecField;
		for (auto& it0 : ownerType->GetTypeLayout().m_vecSubobject)
		{
			for (auto& it1 : it0->GetFields())
				vecField.push_back(it1);
		}
		ASSERT(vecField.size() == rw->GetNodesCount());
		for (uint32 idx = 0; idx < rw->GetNodesCount(); ++idx)
		{
			auto& field = vecField[idx];
			auto fieldType = field.GetType();
			auto& propType = g_mapAcsToPropType.at(GetAccessorType(fieldType));
			auto fieldProp = Niflect::NiflectTypeMakeShared<CPropertyNode>(propType);
			BuildPropertyFromRwNodeRecurs(editCtx, fieldType, rw->GetNode(idx), field.GetName(), prop, fieldProp.Get());
			prop->AddNode(fieldProp);
		}
	}
}
static CSharedPropertyNode BuildPropertyFromRwNode(CPropertyEditContext* editCtx, Niflect::CNiflectType* ownerType, const CRwNode* rw)
{
	auto& propType = g_mapAcsToPropType.at(GetAccessorType(ownerType));
	auto prop = Niflect::NiflectTypeMakeShared<CPropertyNode>(propType);
	BuildPropertyFromRwNodeRecurs(editCtx, ownerType, rw, "", NULL, prop.Get());
	return prop;
}

QExampleWindow::QExampleWindow(QWidget* parentWidget)
	: inherited(parentWidget)
	, m_cobCollection(NULL)
	, m_propTree(NULL)
	, m_lastSelectedType(NULL)
{
	g_mapAcsToPropType.insert({ Niflect::StaticGetType<CFloatAccessor>(), Niflect::StaticGetType<CFloatPropertyLineEdit>() });
	g_mapAcsToPropType.insert({ Niflect::StaticGetType<CCompoundAccessor>(), Niflect::StaticGetType<CCompoundPropertyCollapser>() });
	g_mapAcsToPropType.insert({ Niflect::StaticGetType<CArrayAccessor>(), Niflect::StaticGetType<CArrayPropertyAddRemoveDeleteInsert>() });


	auto wdgCentral = new QWidget(this);
	this->setCentralWidget(wdgCentral);
	auto mainLayout = new QHBoxLayout(wdgCentral);

	auto cobCollection = new QComboBox(this);
	QObject::connect(cobCollection, &QComboBox::currentTextChanged, [this]()
		{
			auto& type = m_vecType[m_cobCollection->currentIndex()];
			CRwNode rwInitialRuntimeData;
			{
				m_runtimeDummy = Niflect::NiflectTypeMakeShared<void*>(type);
				type->SaveInstanceToRwNode(m_runtimeDummy.Get(),  &rwInitialRuntimeData);
				m_runtimeInstRoot.Clear();
				m_runtimeInstRoot.InitAndBuild(type, m_runtimeDummy.Get());
			}
			{
				m_propRoot = BuildPropertyFromRwNode(&m_editCtx, type, &rwInitialRuntimeData);
				DebugPrintPropertyRecurs(m_propRoot.Get());
				auto uiNodeRoot = m_propTree->GetUiNodeRoot();
				m_propTree->RebuildRows(m_propRoot.Get(), uiNodeRoot);
			}
		});
	mainLayout->addWidget(cobCollection);
	m_cobCollection = cobCollection;

	auto btnPrint = new QPushButton("Print", this);
	QObject::connect(btnPrint, &QPushButton::clicked, [this]()
		{
			printf("----------------\n");
			DebugPrintPropertyRecurs(m_propRoot.Get());
		});
	mainLayout->addWidget(btnPrint);

	m_propTree = new QPropertyTree(this);
	m_propTree->Init(&m_editCtx);
	m_propTree->SetOnChangeFromUiAppliedFunc([this](CPropertyNode* prop)
		{
			Niflect::TArray<Niflect::CString> vecPath;
			CRwNode rw;
			{
				Niflect::BuildNamePathForTypeHasGetNameGetParent(prop, vecPath);
				prop->SaveForInstanceNode(&rw);
			}
			{
				auto runtimeInstNode = Niflect::VisitInstanceNodeByNamePath(&m_runtimeInstRoot, vecPath);
				runtimeInstNode->Load(&rw);
				if (!prop->IsItem())
				{
					runtimeInstNode->Clear();
					runtimeInstNode->Build();
				}
			}
			{
				CRwNode rw;
				m_runtimeInstRoot.GetType()->SaveInstanceToRwNode(m_runtimeDummy.Get(), &rw);
				std::ofstream ofs;
				if (NiflectUtil::OpenFileStream(ofs, "a.json"))
					CJsonFormat::Write(&rw, ofs);
			}
		});
	mainLayout->addWidget(m_propTree);

	//m_propRoot = Niflect::MakeShared<CCompoundPropertyCollapser>();
	//m_propRoot->InitForNode(&m_editCtx, NULL, "");
	//auto field0 = Niflect::MakeShared<CFloatPropertyLineEdit>();
	//field0->InitForNode(&m_editCtx, m_propRoot.Get(), "field0");
	//m_propRoot->AddNode(field0);
	//field0->SetValue(1.23f);
	//auto field1 = Niflect::MakeShared<CArrayPropertyAddRemoveDeleteInsert>();
	//field1->InitForNode(&m_editCtx, m_propRoot.Get(), "field1");
	//field1->InitForContainer(Niflect::StaticGetType<CFloatPropertyLineEdit>());
	//m_propRoot->AddNode(field1);
	//field1->Resize(3);
	//DebugPrintPropertyRecurs(m_propRoot.Get());
	//auto uiNodeRoot = m_propTree->GetUiNodeRoot();
	//m_propTree->RebuildRows(m_propRoot.Get(), uiNodeRoot);
}
void QExampleWindow::InitTypesSelection(const Niflect::CNiflectTable* table)
{
	for (uint32 idx = 0; idx < table->GetTypesCount(); ++idx)
	{
		auto type = table->GetTypeByIndex(idx);
		if (type->GetNata() != NULL)
		{
			m_vecType.push_back(type);
			m_cobCollection->addItem(CStringToQString(type->GetTypeName()));
		}
	}
}#include "Qt/Widget/PropertyRow.h"
#include "qpushbutton.h"
#include "Qt/Util/WidgetUtil.h"
#include "qpainter.h"

class QRowItem : public QWidget
{
	typedef QWidget inherited;
public:
	QRowItem(QWidget* parentWidget);

public:
	virtual void paintEvent(QPaintEvent* event) override;
};

QRowItem::QRowItem(QWidget* parentWidget)
	: inherited(parentWidget)
{
}
void QRowItem::paintEvent(QPaintEvent* event)
{
	inherited::paintEvent(event);
	//QPainter painter(this);
	//auto rc = this->rect();
	//QPen pen;
	//pen.setColor(Qt::red);
	//painter.setPen(pen);
	//painter.setBrush(Qt::NoBrush);
	//painter.drawRect(rc);
}

QPropertyRow::QPropertyRow(QWidget* parentWidget)
	: inherited(parentWidget)
	, m_mainLayout(NULL)
	, m_column0(NULL)
	, m_column1(NULL)
	, m_indentLayout(NULL)
	, m_labelLayout(NULL)
	, m_editLayout(NULL)
	, m_toolLayout(NULL)
	, m_splitter(NULL)
	//, m_caption(NULL)
	, m_reset(NULL)
{
	m_mainLayout = CreateLayoutNoMargin<QHBoxLayout>(this);
	//mainLayout->setAlignment(Qt::AlignmentFlag::AlignLeft);
	{
		m_column0 = new QRowItem(this);
		auto column0Layout = CreateLayoutNoMargin<QHBoxLayout>(m_column0);
		auto indentArea = new QWidget(this);
		m_indentLayout = CreateLayoutNoMargin<QHBoxLayout>(indentArea);
		column0Layout->addWidget(indentArea);
		{
			auto labelArea = new QWidget(this);
			m_labelLayout = CreateLayoutNoMargin<QHBoxLayout>(labelArea);
			column0Layout->addWidget(labelArea);
		}
	}
	{
		m_column1 = new QRowItem(this);
		auto column1Layout = CreateLayoutNoMargin<QHBoxLayout>(m_column1);
		{
			auto editArea = new QWidget(this);
			m_editLayout = CreateLayoutNoMargin<QHBoxLayout>(editArea);
			column1Layout->addWidget(editArea);
		}
		{
			auto toolArea = new QWidget(this);
			m_toolLayout = CreateLayoutNoMargin<QHBoxLayout>(toolArea);
			column1Layout->addWidget(toolArea);
		}
	}
}
void QPropertyRow::InitIndents(uint32 cnt)
{
	auto indentArea = m_indentLayout->widget();
	int32 diff = static_cast<uint32>(m_vecIndent.size()) - cnt;
	while (diff > 0)
	{
		delete m_vecIndent[0];
		m_vecIndent.erase(m_vecIndent.begin());
		diff--;
	}
	diff = cnt - static_cast<uint32>(m_vecIndent.size());
	while (diff > 0)
	{
		auto indentWdg = new QPushButton("-", indentArea);
		indentWdg->setFixedWidth(20);
		indentWdg->setFlat(true);
		m_vecIndent.push_back(indentWdg);
		m_indentLayout->addWidget(indentWdg);
		diff--;
	}
	ASSERT(m_vecIndent.size() == cnt);
}
void QPropertyRow::Init2Columns()
{
	m_splitter = new QSplitter(this);
	m_splitter->addWidget(m_column0);
	m_splitter->addWidget(m_column1);

	m_mainLayout->addWidget(m_splitter);
}
void QPropertyRow::InitSection()
{
	m_mainLayout->addWidget(m_column0);
	m_mainLayout->addWidget(m_column1);
}
void QPropertyRow::InitResetter()
{
	m_reset = new QPushButton("rst", this);
	m_reset->setFixedWidth(40);
	QObject::connect(m_reset, &QPushButton::clicked, [this]()
		{
			m_OnRowResetFunc();
		});
	m_toolLayout->addWidget(m_reset);
}
void QPropertyRow::SetEnabledResettter(bool b)
{
	m_reset->setEnabled(b);
	m_reset->setFlat(!m_reset->isEnabled());
}#include "Qt/Widget/PropertyTree.h"
#include "PropertyEditorSystem.h"
#include "qpushbutton.h"
#include "Qt/Util/CoreUtil.h"

QPropertyTree::QPropertyTree(QWidget* parentWidget)
	: inherited(parentWidget)
	, m_mainLayout(NULL)
	, m_rowsLayout(NULL)
	, m_editCtx(NULL)
	, m_firstShown(true)
{
	m_mainLayout = new QVBoxLayout(this);
	m_rowsLayout = new QVBoxLayout;
	m_rowsLayout->setAlignment(Qt::AlignmentFlag::AlignTop);
	m_mainLayout->addLayout(m_rowsLayout);
}
QPropertyTree::~QPropertyTree()
{
	printf("");
}
void QPropertyTree::Init(CPropertyEditContext* editCtx)
{
	m_editCtx = editCtx;
}
void QPropertyTree::RebuildRows(CPropertyNode* prop, CPropertyUiNode* uiNode)
{
	this->SaveDefaultForJustAdded();
	auto insertingIdx = this->FindRowIndex(uiNode);
	this->DeleteRows(uiNode);
	this->BuildRows(prop, uiNode);
	this->InsertRows(uiNode, insertingIdx);
}
uint32 QPropertyTree::FindRowIndex(const CPropertyUiNode* uiNode) const
{
	uint32 insertIdx = 0;
	if (uiNode->m_row != NULL)
		insertIdx = m_rowsLayout->indexOf(uiNode->m_row);
	return insertIdx;
}
void QPropertyTree::RebuildUpdateNotify(CPropertyUiNode* uiNode)
{
	auto& prop = uiNode->m_dataNode;
	if (!prop->IsItem())
		this->RebuildRows(prop, uiNode);
	this->UpdateResetter(uiNode);
	m_OnChangeFromUiAppliedFunc(prop);
}
void QPropertyTree::MarkChangeFromUi(CPropertyNode* prop)
{
	CRwNode rw;
	if (prop->LoadFromUi(&rw))
		prop->SaveToCurrent(&rw);
	this->RebuildUpdateNotify(prop->m_uiNode);
}
void QPropertyTree::ResetBranchRecurs(CPropertyNode* prop)
{
	if (prop->LoadFromDefault())
		this->SaveDefaultForJustAdded();//如数组型可能添加节点, 因此须保存默认值
	for (auto& it : prop->m_vecNode)
		this->ResetBranchRecurs(it.Get());
}
void QPropertyTree::ResetBranch(CPropertyUiNode* uiNode)
{
	auto& prop = uiNode->m_dataNode;
	this->ResetBranchRecurs(prop);
	CRwNode rw;
	if (prop->LoadFromCurrent(&rw))
		prop->SaveToUi(&rw);
	this->RebuildUpdateNotify(uiNode);
}
void QPropertyTree::BuildRowsRecurs(CPropertyNode* prop, CPropertyUiNode* uiNode, uint32 depth)
{
	prop->InitForUi(uiNode);

	{
		auto row = new QPropertyRow(this);
		row->InitIndents(depth);
		row->SetOnRowResetFunc([this, uiNode]()
			{
				this->ResetBranch(uiNode);

			});

		auto cap = prop->m_name;
		if (cap.empty())
			cap = "(No named)";// cap = prop->m_instNode->GetType()->GetTypeName();
		uiNode->InitRowWidget(this, prop, row, cap);
	}

	depth++;
	for (uint32 idx = 0; idx < prop->m_vecNode.size(); ++idx)
	{
		auto propChild = prop->m_vecNode[idx].Get();
		auto uiChild = Niflect::MakeShared<CPropertyUiNode>();
		this->BuildRowsRecurs(propChild, uiChild.Get(), depth);
		{
			CChildEditWidgetCreationContext ctx(propChild, uiChild->m_row);
			if (auto& Func = prop->m_OnCreateChildEditWidgetFunc)
				Func(ctx, idx);
			else
				prop->CreateChildEditWidget(ctx, idx);
		}
		uiNode->AddNode(uiChild);
	}
}
//包括传入节点的 DFS 收集
static void CollectRowsRecurs(CPropertyUiNode* ui, Niflect::TArray<CPropertyUiNode*>& vecNode, Niflect::TArray<QPropertyRow*>& vecRow, Niflect::TSet<QPropertyRow*>& setRow)
{
	if (ui->m_row != NULL)
	{
		if (setRow.insert(ui->m_row).second)
			vecRow.push_back(ui->m_row);
		vecNode.push_back(ui);
	}
	for (auto& it : ui->m_vecNode)
		CollectRowsRecurs(it.Get(), vecNode, vecRow, setRow);
}
void QPropertyTree::BuildRows(CPropertyNode* prop, CPropertyUiNode* uiNode)
{
	uint32 depth = 0;
	auto par = prop->m_parent;
	while (par != NULL)
	{
		depth++;
		par = par->m_parent;
	}
	this->BuildRowsRecurs(prop, uiNode, depth);

	this->SaveToRows(uiNode);
}
void QPropertyTree::SaveDefaultForJustAdded() const
{
	for (auto& it : m_editCtx->m_vecChanged)
	{
		if (!it->IsDefaultValid())
			it->SaveToDefault();
	}
	m_editCtx->m_vecChanged.clear();
}
void QPropertyTree::SaveToRows(CPropertyUiNode* uiNode) const
{
	Niflect::TArray<CPropertyUiNode*> vecNode;
	Niflect::TArray<QPropertyRow*> vecRow;
	Niflect::TSet<QPropertyRow*> setRow;
	CollectRowsRecurs(uiNode, vecNode, vecRow, setRow);
	for (auto& it : vecNode)
	{
		auto& prop = it->m_dataNode;
		CRwNode rw;
		if (prop->LoadFromCurrent(&rw))
			prop->SaveToUi(&rw);
	}
}
void QPropertyTree::DeleteRows(CPropertyUiNode* uiNode) const
{
	Niflect::TArray<CPropertyUiNode*> vecNode;
	Niflect::TArray<QPropertyRow*> vecRow;
	Niflect::TSet<QPropertyRow*> setRow;
	CollectRowsRecurs(uiNode, vecNode, vecRow, setRow);
	for (auto& it : vecNode)
	{
		it->ResetForRebuilding();
	}
	for (auto& it : vecRow)
	{
		delete it;
	}
	uiNode->m_vecNode.clear();
}
void QPropertyTree::UpdateResetter(CPropertyUiNode* uiNode) const
{
	bool enabled = this->UpdateResetterRecurs(uiNode);
	auto par = uiNode->m_dataNode->m_parent;
	if (enabled)
	{
		while (par != NULL)
		{
			par->m_uiNode->m_row->SetEnabledResettter(enabled);
			par = par->m_parent;
		}
	}
	else if (par != NULL)
	{
		par->m_uiNode->m_row->SetEnabledResettter(enabled);
	}
}
void QPropertyTree::UpdateRowsExpansion(CPropertyUiNode* uiNode) const
{
	this->UpdateRowsExpansionRecurs(uiNode);
}
void QPropertyTree::UpdateRowsExpansionRecurs(CPropertyUiNode* uiNode) const
{
	bool isParentRowExpanded = true;
	if (auto cps = uiNode->m_collapser)
		isParentRowExpanded = cps->IsExpanded();
	if (isParentRowExpanded)
	{
		for (auto& it : uiNode->m_vecNode)
		{
			it->m_row->setVisible(isParentRowExpanded);
			this->UpdateRowsExpansionRecurs(it.Get());
		}
	}
	else
	{
		Niflect::TArray<CPropertyUiNode*> vecNode;
		Niflect::TArray<QPropertyRow*> vecRow;
		Niflect::TSet<QPropertyRow*> setRow;
		for (auto& it : uiNode->m_vecNode)
			CollectRowsRecurs(it.Get(), vecNode, vecRow, setRow);
		for (auto& it : vecRow)
			it->setVisible(false);
	}
}
bool QPropertyTree::UpdateResetterRecurs(CPropertyUiNode* uiNode) const
{
	bool enabled = false;
	for (auto& it : uiNode->m_vecNode)
	{
		if (this->UpdateResetterRecurs(it.Get()))
			enabled = true;
	}
	if (!enabled)
	{
		auto& prop = uiNode->m_dataNode;
		if (prop->IsDefaultValid())
		{
			CRwNode rw;
			if (prop->LoadFromCurrent(&rw))
				enabled = !prop->IsEqualToDefault(&rw);
		}
		uiNode->m_row->SetEnabledResettter(enabled);
	}
	return enabled;
}
void QPropertyTree::UpdateRowsResetterAndAdjustSplitterAndUpdateExpansion(CPropertyUiNode* uiNode) const
{
	Niflect::TArray<CPropertyUiNode*> vecNode;
	Niflect::TArray<QPropertyRow*> vecRow;
	Niflect::TSet<QPropertyRow*> setRow;
	CollectRowsRecurs(uiNode, vecNode, vecRow, setRow);

	this->UpdateResetter(uiNode);

	auto width = this->width();
	QList<int> lstColumnWidth;
	int w0 = width / 2;
	lstColumnWidth.push_back(w0);
	lstColumnWidth.push_back(width - w0);
	for (auto& it : vecRow)
	{
		if (it->m_splitter != NULL)
			it->m_splitter->setSizes(lstColumnWidth);
	}

	this->UpdateRowsExpansionRecurs(uiNode);
}
void QPropertyTree::InsertRows(CPropertyUiNode* uiNode, uint32 insertIdx) const
{
	Niflect::TArray<CPropertyUiNode*> vecNode;
	Niflect::TArray<QPropertyRow*> vecRow;
	Niflect::TSet<QPropertyRow*> setRow;
	CollectRowsRecurs(uiNode, vecNode, vecRow, setRow);
	for (uint32 idx = 0; idx < vecRow.size(); ++idx)
	{
		auto& row = vecRow[idx];
		row->InitResetter();
		m_rowsLayout->insertWidget(insertIdx + idx, row);
	}

	if (!m_firstShown)//避免在首次 resizeEvent 执行前获取到未调整完成的宽度
		this->UpdateRowsResetterAndAdjustSplitterAndUpdateExpansion(uiNode);
}
void QPropertyTree::showEvent(QShowEvent* event)
{
	inherited::showEvent(event);
	if (m_uiNodeRoot.IsValid())
		this->UpdateRowsResetterAndAdjustSplitterAndUpdateExpansion(&m_uiNodeRoot);
	m_firstShown = false;
}#include "Qt/Widget/PropertyUiNode.h"
#include "Qt/Util/CoreUtil.h"
#include "Qt/Util/WidgetUtil.h"
#include "Qt/Widget/PropertyRow.h"
#include "Qt/Widget/PropertyTree.h"

void CPropertyUiNode::InitRowWidget(QPropertyTree* tree, CPropertyNode* dataNode, QPropertyRow* row, const Niflect::CString& caption)
{
	m_tree = tree;
	m_dataNode = dataNode;
	m_row = row;
	m_caption = caption;

	{
		ASSERT(m_labelWidget == NULL);
		ASSERT(m_editWidget == NULL);
		CEditWidgetCreationContext ctx(m_dataNode, m_row, m_labelWidget, m_editWidget);
		if (auto& Func = m_dataNode->m_OnCreateEditWidgetFunc)
			m_dataNode->m_OnCreateEditWidgetFunc(ctx);
		else
			m_dataNode->CreateEditWidget(ctx);
	}

	if (m_dataNode->IsItem())
	{
		m_row->Init2Columns();
		if (m_labelWidget == NULL)
		{
			auto btn = new QPushButton(m_row);
			InitPushButtonInPropertyLabelStyle(btn);
			btn->setText(CStringToQString(m_caption));
			m_labelWidget = btn;
		}
	}
	else
	{
		m_row->InitSection();
		if (m_labelWidget == NULL)
		{
			auto cps = new QCollapser(m_row);
			InvokeNoSignal(cps, &QCollapser::SetExpanded, true);//折叠消耗更少, 但为方便测试操作, 默认改为展开
			cps->setText(CStringToQString(m_caption));
			cps->SetOnCollapserExpandedFunc([this, cps]()
				{
					m_tree->UpdateRowsExpansion(this);
				});
			m_collapser = cps;
			m_labelWidget = m_collapser;
		}
	}

	if (m_labelWidget != NULL)
		m_row->m_labelLayout->addWidget(m_labelWidget);
	if (m_editWidget != NULL)
		m_row->m_editLayout->addWidget(m_editWidget);

	m_dataNode->InitWithUiNode();
}

QCollapser::QCollapser(QWidget* parentWidget)
	: inherited(parentWidget)
	, m_expanded(false)
{
	InitPushButtonInPropertyLabelStyle(this);
	QObject::connect(this, &QCollapser::clicked, [this]()
		{
			m_expanded = !m_expanded;
			m_OnCollapserExpandedFunc();
		});
}
bool QCollapser::IsExpanded() const
{
	return m_expanded;
}
void QCollapser::SetExpanded(bool b)
{
	m_expanded = b;
	emit QCollapser::clicked();
}
void QCollapser::SetOnCollapserExpandedFunc(const OnCollapserExpandedFunc& Func)
{
	m_OnCollapserExpandedFunc = Func;
}

bool CFloatPropertyLineEdit::SaveToUiImpl(const CRwNode* rw) const
{
	auto edt = this->GetEditWidget();
	InvokeNoSignal(edt, &QLineEdit::setText, QString("%1").arg(GetRwValueAs<float>(rw->GetValue())));
	return true;
}
bool CFloatPropertyLineEdit::LoadFromUiImpl(CRwNode* rw) const
{
	auto edt = this->GetEditWidget();
	SetRwValueAs<float>(rw->ToValue(), edt->text().toFloat());
	return true;
}
void CFloatPropertyLineEdit::InitWithUiNode()
{
	auto edt = this->GetEditWidget();
	QObject::connect(edt, &QLineEdit::textChanged, [this]()
		{
			m_uiNode->m_tree->MarkChangeFromUi(this);
		});
}
void CFloatPropertyLineEdit::CreateEditWidget(CEditWidgetCreationContext& ctx)
{
	auto edt = new QLineEdit(ctx.m_inRow);
	ctx.m_outEditWidget = edt;
}
QLineEdit* CFloatPropertyLineEdit::GetEditWidget() const
{
	ASSERT(dynamic_cast<QLineEdit*>(m_uiNode->m_editWidget) != NULL);
	return static_cast<QLineEdit*>(m_uiNode->m_editWidget);
}

QAddRemoveButtons::QAddRemoveButtons(QWidget* parentWidget)
	: inherited(parentWidget)
	, m_add(NULL)
	, m_remove(NULL)
{
	auto mainLayout = CreateLayoutNoMargin<QHBoxLayout>(this);
	m_add = CreateSmallButton("add", this);
	QObject::connect(m_add, &QPushButton::clicked, [this]()
		{
			m_OnAddFunc();
		});
	mainLayout->addWidget(m_add);
	m_remove = CreateSmallButton("rmv", this);
	QObject::connect(m_remove, &QPushButton::clicked, [this]()
		{
			m_OnRemoveFunc();
		});
	mainLayout->addWidget(m_remove);
}
void QAddRemoveButtons::SetOnArrayEditAdd(const OnArrayEditAddFunc& Func)
{
	m_OnAddFunc = Func;
}
void QAddRemoveButtons::SetOnArrayEditRemove(const OnArrayEditRemoveFunc& Func)
{
	m_OnRemoveFunc = Func;
}
void QAddRemoveButtons::UpdateButtonsState(uint32 currentItemsCount)
{
	m_remove->setEnabled(currentItemsCount > 0);
}

QInsertDeleteButtons::QInsertDeleteButtons(QWidget* parentWidget)
	: inherited(parentWidget)
	, m_insert(NULL)
	, m_delete(NULL)
{
	auto mainLayout = CreateLayoutNoMargin<QHBoxLayout>(this);
	m_insert = CreateSmallButton("ins", this);
	QObject::connect(m_insert, &QPushButton::clicked, [this]()
		{
			m_OnInsertFunc();
		});
	mainLayout->addWidget(m_insert);
	m_delete = CreateSmallButton("del", this);
	QObject::connect(m_delete, &QPushButton::clicked, [this]()
		{
			m_OnDeleteFunc();
		});
	mainLayout->addWidget(m_delete);
}
void QInsertDeleteButtons::SetOnArrayElementEditInsertFunc(const OnArrayElementEditInsertFunc& Func)
{
	m_OnInsertFunc = Func;
}
void QInsertDeleteButtons::SetOnArrayElementEditDeleteFunc(const OnArrayElementEditDeleteFunc& Func)
{
	m_OnDeleteFunc = Func;
}

void CArrayPropertyAddRemoveDeleteInsert::CreateEditWidget(CEditWidgetCreationContext& ctx)
{
	auto aed = new QAddRemoveButtons(ctx.m_inRow);
	aed->SetOnArrayEditAdd([this]()
		{
			m_editCtx->MarkChanged(this);
			this->AddElement();
			m_uiNode->m_tree->MarkChangeFromUi(this);
		});
	aed->SetOnArrayEditRemove([this]()
		{
			m_editCtx->MarkChanged(this);
			this->DeleteLastElement();
			m_uiNode->m_tree->MarkChangeFromUi(this);
		});
	aed->UpdateButtonsState(ctx.m_inProp->GetNodesCount());//现数组操作后整个分支重建, 因此仅在此更新即可
	ctx.m_outEditWidget = aed;
}
void CArrayPropertyAddRemoveDeleteInsert::CreateChildEditWidget(CChildEditWidgetCreationContext& ctx, uint32 idx)
{
	auto eed = new QInsertDeleteButtons(ctx.m_inRow);
	eed->SetOnArrayElementEditInsertFunc([this, idx]()
		{
			m_editCtx->MarkChanged(this);
			this->InsertElement(idx);
			m_uiNode->m_tree->MarkChangeFromUi(this);
		});
	eed->SetOnArrayElementEditDeleteFunc([this, idx]()
		{
			m_editCtx->MarkChanged(this);
			this->DeleteElement(idx);
			m_uiNode->m_tree->MarkChangeFromUi(this);
		});
	ctx.m_inRow->m_toolLayout->addWidget(eed);
}#pragma once
#include "qmainwindow.h"
#include "Niflect/NiflectTable.h"
#include "qcombobox.h"
#include "Niflect/Base/SharedPtr.h"
#include "Property/PropertyNode.h"
#include "Property/PropertyEditContext.h"

class QPropertyTree;

class QExampleWindow : public QMainWindow
{
	typedef QMainWindow inherited;
public:
	QExampleWindow(QWidget* parentWidget = NULL);
	void InitTypesSelection(const Niflect::CNiflectTable* table);

private:
	QComboBox* m_cobCollection;
	Niflect::TArray<Niflect::CNiflectType*> m_vecType;
	QPropertyTree* m_propTree;
	Niflect::TSharedPtr<void*> m_editorDummy;
	Niflect::TSharedPtr<void*> m_runtimeDummy;
	CSharedPropertyNode m_propRoot;
	Niflect::CNiflectInstanceNode m_editorInstRoot;
	Niflect::CNiflectInstanceNode m_runtimeInstRoot;
	const Niflect::CNiflectType* m_lastSelectedType;
	CPropertyEditContext m_editCtx;
};#pragma once
#include "Niflect/Base/Array.h"
#include "qwidget.h"
#include "qboxlayout.h"
#include "qsplitter.h"
#include "qpushbutton.h"
#include <functional>

class QRowItem;

using OnRowResetFunc = std::function<void()>;

class QPropertyRow : public QWidget
{
	typedef QWidget inherited;
public:
	QPropertyRow(QWidget* parentWidget);

public:
	void InitIndents(uint32 cnt);
	void Init2Columns();
	void InitSection();
	void InitResetter();

public:
	void SetEnabledResettter(bool b);
	void SetOnRowResetFunc(const OnRowResetFunc& Func)
	{
		m_OnRowResetFunc = Func;
	}

public:
	QHBoxLayout* m_indentLayout;
	QHBoxLayout* m_labelLayout;
	QHBoxLayout* m_editLayout;
	QHBoxLayout* m_toolLayout;
	QSplitter* m_splitter;
	Niflect::TArray<QWidget*> m_vecIndent;
	QHBoxLayout* m_mainLayout;
	QRowItem* m_column0;
	QRowItem* m_column1;
	QPushButton* m_reset;
	OnRowResetFunc m_OnRowResetFunc;
};#pragma once
#include "Niflect/Base/Array.h"
#include "Qt/Widget/PropertyRow.h"
#include "qboxlayout.h"
#include "Qt/Widget/PropertyUiNode.h"
#include "Property/PropertyEditContext.h"

using OnChangeFromUiAppliedFunc = std::function<void(CPropertyNode* prop)>;

class QPropertyTree : public QWidget
{
	typedef QWidget inherited;
	friend class CPropertyEditContext;
public:
	QPropertyTree(QWidget* parentWidget);
	virtual ~QPropertyTree() override;

public:
	void Init(CPropertyEditContext* editCtx);
	CPropertyUiNode* GetUiNodeRoot() { return &m_uiNodeRoot; }
	void RebuildRows(CPropertyNode* prop, CPropertyUiNode* uiNode);
	void UpdateRowsExpansion(CPropertyUiNode* uiNode) const;

private:
	uint32 FindRowIndex(const CPropertyUiNode* uiNode) const;
	void DeleteRows(CPropertyUiNode* uiNode) const;
	void BuildRows(CPropertyNode* prop, CPropertyUiNode* uiNode);
	void InsertRows(CPropertyUiNode* uiNode, uint32 insertIdx) const;
	void SaveDefaultForJustAdded() const;
	void SaveToRows(CPropertyUiNode* uiNode) const;

private:
	void BuildRowsRecurs(CPropertyNode* prop, CPropertyUiNode* uiNode, uint32 depth);
	void ResetBranch(CPropertyUiNode* uiNode);
	void ResetBranchRecurs(CPropertyNode* prop);
	void UpdateRowsResetterAndAdjustSplitterAndUpdateExpansion(CPropertyUiNode* uiNode) const;
	void UpdateResetter(CPropertyUiNode* uiNode) const;
	bool UpdateResetterRecurs(CPropertyUiNode* uiNode) const;
	void RebuildUpdateNotify(CPropertyUiNode* uiNode);
	void UpdateRowsExpansionRecurs(CPropertyUiNode* uiNode) const;

public:
	void MarkChangeFromUi(CPropertyNode* prop);

public:
	void SetOnChangeFromUiAppliedFunc(const OnChangeFromUiAppliedFunc& Func) { m_OnChangeFromUiAppliedFunc = Func; }

public:
	virtual void showEvent(QShowEvent* event) override;

private:
	QVBoxLayout* m_mainLayout;
	QVBoxLayout* m_rowsLayout;
	OnChangeFromUiAppliedFunc m_OnChangeFromUiAppliedFunc;
	CPropertyUiNode m_uiNodeRoot;
	CPropertyEditContext* m_editCtx;
	bool m_firstShown;
};